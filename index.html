<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1" />
<title>Startpage</title>
<meta name="description" content="start page of buttons linking to other pages." />
<style>
* { box-sizing: border-box }
html, body { height: 100% }
body {
margin: 0; color: #e7edf6;
font-family: Inter, system-ui, -apple-system, Segoe UI, Roboto, Helvetica, Arial, "Apple Color Emoji", "Segoe UI Emoji";
background-attachment: fixed;
background: #0a101a;
}
/* container */
.container {
padding: 32px 22px 40px;
max-width: 1100px;
margin: 0 auto;
}
/* header */
header {
align-items: center;
margin: 8px 0 22px;
display: flex;
gap: 16px;
}
.logo {
display: grid; place-items: center;
color: white; letter-spacing: -0.5px;
height: 48px; width: 48px; min-width: 48px; 
box-shadow: 0 10px 30px rgba(0,0,0,.35), inset 0 1px 0 rgba(255,255,255,.05);
user-select: none; border-radius: 14px;
border: 1px solid #203456;
background: #152238; 
font-weight: 800; 
font-size: 28px;
}
h1 {
font-size: clamp(22px, 2.4vw, 28px);
margin: 0; letter-spacing: -0.4px;
}
p {
margin: 2px 0px; font-size: 12px;
letter-spacing: -0.4px;
color: #9fb0c7;
}
/* Search */
.search {
display: grid;
grid-template-columns: 1fr auto;
gap: 12px;
background: #0a101a;
border: 1px solid #1c2d49;
border-radius: 18px;
padding: 12px 14px;
box-shadow: 0 10px 30px rgba(0,0,0,.35), inset 0 1px 0 rgba(255,255,255,.05);
}
.search input {
background: transparent;
border: none; outline: none;
color: var(--fg); font-size: 14px;
}
/* placeholder color (cross-browser) */
.search input::-webkit-input-placeholder { 
color: #9fb0c7; opacity: 1; } 
.search input:-ms-input-placeholder { 
color: #9fb0c7; opacity: 1; } 
.search input::placeholder { 
color: #9fb0c7; opacity: 70%; }

/* Grid */
.grid {
--size: 210px;
display: grid;
grid-template-columns: repeat(auto-fill, minmax(var(--size), 1fr));
gap: 16px;
margin-top: 18px;
}
/* Card Link */
.tile {
position: relative;
display: block;
text-decoration: none;
color: inherit;
background: #0d1522;
border: 1px solid #1c2d49;
padding: 18px;
border-radius: 18px;
box-shadow: 0 10px 30px rgba(0,0,0,.35), inset 0 1px 0 rgba(255,255,255,.05);
overflow: hidden;
transition: transform .16s ease, box-shadow .2s ease, border-color .2s ease, background .2s ease;
}
.tile:hover { 
border-color: #23385b;
box-shadow: 0 10px 30px rgba(0,0,0,.35), inset 0 1px 0 rgba(255,255,255,.05);
transform: translateY(-1px); 
}
.tile:focus-visible { 
outline: none; box-shadow: 0 10px 30px rgba(0,0,0,.35), inset 0 1px 0 rgba(255,255,255,.05);
border-color: #234f9b;
}
.tile .icon {
background: #1c3051; 
border: 1px solid #24406f;
border-radius: 12px; font-size: 24px;
display: grid; place-items: center; 
width: 48px; height: 48px; 
margin-bottom: 14px;
}
.tile h3 { letter-spacing: -0.2px; 
font-size: 18px; margin: 6px 0 6px; 
}
.tile p { color: #9fb0c7; 
font-size: 14px; margin: 0;
line-height: 1.35; 
}
.hidden { display: none !important }
.sr-only { position: absolute; width: 1px; height: 1px; padding: 0; margin: -1px; overflow: hidden; clip: rect(0,0,0,0); white-space: nowrap; border: 0; }

/* ===== Modal (iframe preview) ===== */
.modal-backdrop {
position: fixed;
inset: 0;
background: rgba(0,0,0,.6);
display: none;
align-items: center;
justify-content: center;
padding: 32px;
z-index: 1000;
}
.modal-backdrop[aria-hidden="false"] { display: flex; }
.modal {
width: min(1100px, 92vw);
height: min(720px, 86vh);
background: #0d1522;
border: 1px solid #3a4250;
border-radius: 16px;
box-shadow: 0 20px 60px rgba(0,0,0,.5);
display: grid;
grid-template-rows: auto 1fr;
overflow: clip;
}
.modal-header {
position: relative;
padding: 10px 14px;
border-bottom: 1px solid #2d3442;
min-height: 48px;
box-sizing: border-box;
background: transparent;
}
.modal-note {
position: absolute; left: 14px; top: 50%; transform: translateY(-50%); white-space: nowrap; z-index: 2; color: #c9d7ee; font-size: 13px; opacity: 0%;
}
.modal-actions {
position: absolute; right: 14px; top: 50%; transform: translateY(-50%); display: inline-flex; gap: 8px; align-items: center; z-index: 2;
}
.icon-btn {
appearance: none; outline: none; border: none; background: transparent; color: #e7edf6;
width: 34px; height: 34px; border-radius: 50%; cursor: pointer; display: grid; place-items: center; font-size: 22px; font-family: Inter, system-ui, -apple-system, Segoe UI, Roboto, Helvetica, Arial, "Apple Color Emoji", "Segoe UI Emoji";
}
#prevBtn {
transform: rotate(180deg);
transform: scaleX(-1);
}
.modal-body { position: relative; }
.modal-iframe { width: 100%; height: 100%; border: 0; background: #0b0f14; }
.modal-open-overlay {
position: absolute; inset: 0; display: none; 
}
</style>
</head>
<body>
<div class="container">

<header>
<div class="logo" aria-hidden>✓</div> 
<!-- Edit "<h1>" and "<p>" text if you want -->
<div><h1>One Most Important Message ?</h1>
<p>THOUGHT-ORIGINATED-CREATIONs for your HIGHEST-SELF to OBSERVE</p></div>
</header>

<!-- Search -->
<label class="search" for="q">
<input id="q" type="search" placeholder="Search…" autocomplete="off" spellcheck="false" />
</label>

<!-- Grid of Links -->
<main class="grid" id="grid" aria-live="polite">

<!-- EDIT BELOW: Duplicate an "<a> </a>" selection for (ADDING MORE BUTTONS)  -->

<!-- copy a selection to duplicate button:
start the selection from line below:

(START of a new TEXT-SELECTION) = 
<a class="tile" href="writings/note.html" tabindex="0"> 
<div class="icon" aria-hidden>✓</div> 
<h3>Writing 1</h3> 
<p>Writing Draft</p>
</a>
(END of the new TEXT-SELECTION) = 


end the selection before this line and copy the selection. Then paste it bellow the other buttons found in code below:  
-->


<!-- remember to 
(UPDATE the NAMEs) of (href="folder/note.html") 
to match your own structure and naming -->

    
    
<a class="tile" href="MESSAGES/ONE.html" tabindex="0"> <!-- update href to match -->
<div class="icon" aria-hidden>✓</div> 
<!-- type whatever you want below-->
<h3>GOODest Cosmic GOALs ?</h3> 
<p>(LESS of BAD) and (MORE of GOOD)</p>
</a>


<a class="tile" href="MESSAGES/TWO.html" tabindex="0"> <!-- update href to match -->
<div class="icon" aria-hidden>✓</div> 
<!-- type whatever you want below-->
<h3>GOODNESS-SEEKING</h3> 
<p>GOODNESS-SEEKING</p>
</a>

    
    
    
<!-- ==== EDIT ABOVE ==== -->
</main>

</div>

<!-- ===== iFrame Modal Markup ===== -->
<div class="modal-backdrop" id="previewBackdrop" aria-hidden="true" aria-modal="true" role="dialog">
<div class="modal" role="document" aria-labelledby="previewTitle">
<div class="modal-header">
<div class="modal-note" id="crossOriginNote" style="display:none"></div>
<div class="modal-actions">
<button class="icon-btn" id="prevBtn" type="button" title="Previous (←)" aria-label="Previous">›</button>
<button class="icon-btn" id="nextBtn" type="button" title="Next (→)" aria-label="Next">›</button>
</div>

</div>
<div class="modal-body">
<iframe id="previewFrame" class="modal-iframe" sandbox="allow-same-origin allow-scripts allow-forms allow-popups allow-pointer-lock allow-downloads"></iframe>
<div class="modal-open-overlay" id="openOverlay" aria-hidden="true"></div>

</div>
</div>
</div>

<script>
// ====== Local helpers ======
const $ = (q, root = document) => root.querySelector(q);
const $$ = (q, root = document) => Array.from(root.querySelectorAll(q));

const q = $('#q');
const grid = $('#grid');
const tiles = $$('.tile', grid);

// ====== Search / Filter ======
function filter(val) {
const v = val.trim().toLowerCase();
let matches = 0;
tiles.forEach(t => {
// include <h3> and <p> text in search
const title = t.querySelector('h3')?.textContent || '';
const desc = t.querySelector('p')?.textContent || '';
const hay = [
t.dataset.title || '',
t.dataset.tags || '',
title,
desc
].join(' ').toLowerCase();

const ok = !v || hay.includes(v);
t.classList.toggle('hidden', !ok);
if (ok) matches++;
});
grid.setAttribute('aria-busy', 'false');
grid.dataset.matches = matches;
}

// live filtering while typing
q.addEventListener('input', e => filter(e.target.value));

// Announce match count 
const live = document.createElement('div');
live.className = 'sr-only';
live.setAttribute('role', 'status');
document.body.appendChild(live);

const mo = new MutationObserver(() => {
const n = grid.dataset.matches || tiles.length;
live.textContent = `${n} link${n == 1 ? '' : 's'} visible`;
});
mo.observe(grid, { attributes: true, attributeFilter: ['data-matches'] });





window.addEventListener("DOMContentLoaded", () => {
const firstTile = document.querySelector(".tile");
if (firstTile) firstTile.focus();
});



// ====== Preview Modal Logic ======
const backdrop = $('#previewBackdrop');
const frame = $('#previewFrame');

const btnOpen= $('#openInNewTabBtn') || null;
const btnClose = $('#closePreviewBtn') || null;
const btnPrev= $('#prevBtn') || null;
const btnNext= $('#nextBtn') || null;

const overlay = $('#openOverlay');
const xoNote= $('#crossOriginNote');

let lastActive = null;
let currentURL = '';
let currentIndex = -1; 

function inferIndexFromHref(href) {
const i = tiles.findIndex(t => t.getAttribute('href') === href);
return i >= 0 ? i : currentIndex;
}

function openPreview(href, label, idx) {
// update index
if (typeof idx === 'number') {
currentIndex = idx;
} else {
currentIndex = inferIndexFromHref(href);
}
currentURL = href;
lastActive = document.activeElement;
frame.removeAttribute('src');
backdrop.setAttribute('aria-hidden', 'false');
document.body.style.overflow = 'hidden';
// reset helpers
overlay && (overlay.style.display = 'none');
xoNote&& (xoNote.style.display= 'none');
// load URL + enable dblclick-to-open 
frame.src = href;
frame.onload = () => {
try {
const doc = frame.contentDocument; 
doc.addEventListener('dblclick', () => { window.location.href = href; });
if (xoNote) {
xoNote.style.display = 'block';
xoNote.textContent = 'Use ← / → to navigate. Double-click inside the preview to open the page.';
}
} catch (e) {
// cross-origin
overlay && (overlay.style.display = 'none');
if (xoNote) {
xoNote.style.display = 'block';
xoNote.textContent = 'This page is cross-origin. Use arrows (or keys) to switch, or open directly.';
}}};
// focus something sensible
if (btnNext) btnNext.focus();
else if (btnClose) btnClose.focus();
}

function focusPreviewedTile() {
if (!Array.isArray(tiles) || tiles.length === 0) return false;
if (typeof currentIndex !== 'number' || currentIndex < 0 || currentIndex >= tiles.length) return false;
const n = tiles.length;
// if the exact tile is visible, use it
let candidate = tiles[currentIndex];
if (candidate && !candidate.classList.contains('hidden')) {
candidate.focus({ preventScroll: true });
candidate.scrollIntoView({ block: 'nearest', inline: 'nearest' });
return true;
}
// otherwise search outward for nearest tile
for (let offset = 1; offset < n; offset++) {
const forward = tiles[(currentIndex + offset) % n];
if (forward && !forward.classList.contains('hidden')) {
forward.focus({ preventScroll: true });
forward.scrollIntoView({ block: 'nearest', inline: 'nearest' });
return true;
}
const backward = tiles[(currentIndex - offset + n) % n];
if (backward && !backward.classList.contains('hidden')) {
backward.focus({ preventScroll: true });
backward.scrollIntoView({ block: 'nearest', inline: 'nearest' });
return true;
}}
return false;
}

function closePreview() {
backdrop.setAttribute('aria-hidden', 'true');
document.body.style.overflow = '';
frame.removeAttribute('src');
// Try to focus tile that was last previewed
const focused = focusPreviewedTile();
if (!focused && lastActive) {
// fallback to previous active element if tile couldn't be focused
try { lastActive.focus({ preventScroll: true }); }
catch (_) { /* ignore */ }
}
}

function openPreviewByIndex(idx) {
if (!tiles.length) return;
const n = tiles.length;
currentIndex = ((idx % n) + n) % n; // wrap
const tile= tiles[currentIndex];
const href= tile.getAttribute('href');
const label = tile.querySelector('h3')?.textContent?.trim() || href;
if (href) openPreview(href, label, currentIndex);
}

// Optional buttons wiring 
if (btnOpen)btnOpen.addEventListener('click', () => { if (currentURL) window.open(currentURL, '_blank', 'noopener'); });
if (btnClose) btnClose.addEventListener('click', closePreview);
if (btnPrev)btnPrev.addEventListener('click', () => openPreviewByIndex(currentIndex - 1));
if (btnNext)btnNext.addEventListener('click', () => openPreviewByIndex(currentIndex + 1));

// Keyboard inside modal
window.addEventListener('keydown', (e) => {
if (backdrop.getAttribute('aria-hidden') !== 'false') return;
if (e.key === 'Escape') {
closePreview();
} else if (e.key === 'ArrowLeft') {
e.preventDefault(); openPreviewByIndex(currentIndex - 1);
} else if (e.key === 'ArrowRight') {
e.preventDefault(); openPreviewByIndex(currentIndex + 1);
} else if (e.key === 'Home') {
e.preventDefault(); openPreviewByIndex(0);
} else if (e.key === 'End') {
e.preventDefault(); openPreviewByIndex(tiles.length - 1);
}});
// Close by clicking outside (backdrop)
backdrop.addEventListener('mousedown', (e) => {
if (e.target === backdrop) closePreview();
});
// Double-click anywhere on modal body
$('.modal-body').addEventListener('dblclick', (e) => {
if (e.target.closest('iframe')) return; // iframe handles its own dblclick
if (currentURL) window.location.href = currentURL;
});


// Right-click + Keyboard on any tile 
tiles.forEach((tile, i) => {
// Right-click => preview
tile.addEventListener('contextmenu', (e) => {
e.preventDefault();
const href= tile.getAttribute('href');
if (!href) return;
const label = tile.querySelector('h3')?.textContent?.trim() || href;
openPreview(href, label, i); // pass index
});
// Keyboard shortcuts on focused tile
tile.addEventListener('keydown', (e) => {
const href= tile.getAttribute('href');
if (!href) return;
const label = tile.querySelector('h3')?.textContent?.trim() || href;
// Shift+Enter => preview
if (e.key === 'Enter' && e.shiftKey) {
e.preventDefault();
e.stopPropagation();
openPreview(href, label, i);
return;
}
// Space => when modal is closed: open preview for focused tile
if (e.code === 'Space' || e.key === ' ' || e.key === 'Spacebar') {
e.preventDefault();
e.stopPropagation();
const isModalOpen = backdrop.getAttribute('aria-hidden') === 'false';
if (isModalOpen) {
// If modal is open, space should act like Esc 
return;
} else {
openPreview(href, label, i);
}
return;
}});
// help assistive tech discover shortcuts
tile.setAttribute('aria-keyshortcuts', 'Space,Shift+Enter');
});


// ======= Global capture listener: 
window.addEventListener('keydown', (e) => {
if (e.key === 'Enter') {
e.preventDefault();
e.stopPropagation();
if (currentURL) {
// open in same tab 
window.location.href = currentURL;
}
return;
}
if (!(e.code === 'Space' || e.key === ' ' || e.key === 'Spacebar')) return;
const isModalOpen = backdrop.getAttribute('aria-hidden') === 'false';
if (!isModalOpen) return;
// If modal open, close preview (like Esc)
e.preventDefault();
e.stopPropagation();
closePreview();
}, true); // <-- capture phase


window.addEventListener('keydown', (e) => {
// ignore combos with modifier keys (except we explicitly allow Shift+Enter to fall-through)
if (e.ctrlKey || e.metaKey || e.altKey) return;
const modalOpen = backdrop.getAttribute('aria-hidden') === 'false';
// don't interfere with form controls or contentEditable
const ae = document.activeElement;
const isFormControl = ae && (/^(INPUT|TEXTAREA|SELECT|BUTTON)$/i.test(ae.tagName) || ae.isContentEditable);
if (isFormControl) return;
// ENTER: when modal open -> open currentURL; when modal closed -> open focused tile's href
if (e.key === 'Enter') {
// Allow Shift+Enter to be handled by per-tile handler (it opens preview).
if (e.shiftKey) return;

if (modalOpen) {
e.preventDefault();
e.stopPropagation();
if (currentURL) window.location.href = currentURL;
return;
} else {
// modal closed: open the href of the focused tile (if any)
// find tile that is the active element or contains the active element
const focusedTile = Array.isArray(tiles) && tiles.find(t => t === ae || t.contains(ae));
if (focusedTile) {
const href = focusedTile.getAttribute('href');
if (href) {
e.preventDefault();
e.stopPropagation();
window.location.href = href;
}
}
return;
}
}
// all other keys: leave them to the other listeners (navigation handlers below)
}, true); // capture phase


// Navigation-only keys
function focusTile(idx) {
if (!tiles || tiles.length === 0) return;
const n = tiles.length;
const i = ((idx % n) + n) % n;
const tile = tiles[i];
if (tile) {
tile.focus({ preventScroll: true });
tile.scrollIntoView({ block: 'nearest', inline: 'nearest' });
}}
function getTileCenters() {
return tiles.map(t => {
const r = t.getBoundingClientRect();
return { x: r.left + r.width / 2, y: r.top + r.height / 2 };
});
}

window.addEventListener('keydown', (e) => {
// ignore combos with modifier keys
if (e.ctrlKey || e.metaKey || e.altKey) return;
const modalOpen = backdrop.getAttribute('aria-hidden') === 'false';
// skip if focus is in a form control or contentEditable
const ae = document.activeElement;
const isFormControl = ae && (/^(INPUT|TEXTAREA|SELECT|BUTTON)$/i.test(ae.tagName) || ae.isContentEditable);
if (isFormControl) return;
// If modal is open: arrow/home/end navigate previews
if (modalOpen) {
if (e.key === 'ArrowLeft'){ e.preventDefault(); openPreviewByIndex(currentIndex - 1); return; }
if (e.key === 'ArrowRight') { e.preventDefault(); openPreviewByIndex(currentIndex + 1); return; }
if (e.key === 'Home') { e.preventDefault(); openPreviewByIndex(0); return; }
if (e.key === 'End'){ e.preventDefault(); openPreviewByIndex(tiles.length - 1); return; }
// ignore ArrowUp/ArrowDown while modal is open
return;
}
// When modal is closed: navigate focus tiles
const focusedIndex = (() => {
const ae = document.activeElement;
return tiles.indexOf(ae);
})();
// Left / Right: p / next tile in DOM order
if (e.key === 'ArrowLeft' || e.key === 'ArrowRight') {
e.preventDefault();
if (tiles.length === 0) return;
if (focusedIndex < 0) { focusTile(0); return; }
if (e.key === 'ArrowLeft') focusTile(focusedIndex - 1);
else focusTile(focusedIndex + 1);
return;
}
// Up / Down: visual nearest tile above/below
if (e.key === 'ArrowUp' || e.key === 'ArrowDown') {
e.preventDefault();
if (tiles.length === 0) return;
const centers = getTileCenters();
if (focusedIndex < 0) { focusTile(0); return; }
const curr = centers[focusedIndex];
if (!curr) { focusTile(0); return; }
const isUp = e.key === 'ArrowUp';
let candidates = centers
.map((c, i) => ({ i, x: c.x, y: c.y, dx: Math.abs(c.x - curr.x), dy: Math.abs(c.y - curr.y) }))
.filter(entry => isUp ? entry.y < curr.y - 2 : entry.y > curr.y + 2);
if (candidates.length === 0) {
if (isUp) focusTile(focusedIndex - 1);
else focusTile(focusedIndex + 1);
return;
}
candidates.sort((a, b) => {
const va = Math.abs(a.y - curr.y), vb = Math.abs(b.y - curr.y);
if (va !== vb) return va - vb;
return a.dx - b.dx;
});
focusTile(candidates[0].i);
return;
}
// Home/End - modal closed => first/last focus
if (e.key === 'Home') { e.preventDefault(); focusTile(0); return; }
if (e.key === 'End'){ e.preventDefault(); focusTile(tiles.length - 1); return; }
}, true); 
</script>
</body>
</html>
